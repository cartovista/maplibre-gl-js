<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Hard Light Blend Mode Example</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <canvas id="canvas" width="800" height="600"></canvas>
    <script>
        const vertexShaderSource = `
            attribute vec4 a_position;
            attribute vec2 a_texCoord;
            varying vec2 v_texCoord;

            void main() {
                gl_Position = a_position;
                v_texCoord = a_texCoord;
            }
        `;

        const hardLightFragmentShaderSource = `
            precision mediump float;

            uniform sampler2D u_texture;
            uniform vec4 u_blendColor;
            varying vec2 v_texCoord;

            // Hard Light blending function
            vec3 hardLight(vec3 base, vec3 blend) {
                return mix(2.0 * base * blend, 1.0 - 2.0 * (1.0 - base) * (1.0 - blend), step(0.5, blend));
            }

            void main() {
                vec4 baseColor = texture2D(u_texture, v_texCoord);
                vec3 blendedColor = hardLight(baseColor.rgb, u_blendColor.rgb);
                gl_FragColor = vec4(blendedColor, baseColor.a);
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShaderSource, fragmentShaderSource) {
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));
                return null;
            }

            return program;
        }

        function createCheckerboardTexture(gl) {
            const size = 8; // Checkerboard size
            const data = new Uint8Array(size * size * 4);
            for (let y = 0; y < size; ++y) {
                for (let x = 0; x < size; ++x) {
                    const offset = (y * size + x) * 4;
                    const isWhite = (x + y) % 2 === 0;
                    data[offset] = isWhite ? 255 : 0;
                    data[offset + 1] = isWhite ? 255 : 0;
                    data[offset + 2] = isWhite ? 255 : 0;
                    data[offset + 3] = 255;
                }
            }

            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

            return texture;
        }

        function drawRectangle(gl, program, texture, blendColor, positions, texCoords) {
            gl.useProgram(program);

            const positionLocation = gl.getAttribLocation(program, "a_position");
            const texCoordLocation = gl.getAttribLocation(program, "a_texCoord");

            const blendColorLocation = gl.getUniformLocation(program, "u_blendColor");
            const textureLocation = gl.getUniformLocation(program, "u_texture");

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            const texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.uniform1i(textureLocation, 0);
            gl.uniform4fv(blendColorLocation, blendColor);

            gl.enableVertexAttribArray(positionLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(texCoordLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        function main() {
            const canvas = document.getElementById('canvas');
            const gl = canvas.getContext('webgl');

            if (!gl) {
                console.error('WebGL not supported');
                return;
            }

            // Create shaders and program
            const program = createProgram(gl, vertexShaderSource, hardLightFragmentShaderSource);

            // Create a checkerboard texture
            const texture = createCheckerboardTexture(gl);

            // Clear canvas
            gl.clearColor(1, 1, 1, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            // Background rectangle (textured)
            const backgroundPositions = [
                -1.0, -1.0,
                 1.0, -1.0,
                -1.0,  1.0,
                 1.0,  1.0,
            ];

            const texCoords = [
                0, 0,
                4, 0,
                0, 4,
                4, 4,
            ];

            // Draw the textured background
            drawRectangle(gl, program, texture, [0, 0, 0, 0], backgroundPositions, texCoords);

            // Red rectangle with HARDLIGHT blending
            const redPositions = [
                -0.5, -0.5,
                 0.5, -0.5,
                -0.5,  0.5,
                 0.5,  0.5,
            ];

            // Draw the red rectangle
            drawRectangle(gl, program, texture, [1, 0, 0, 1], redPositions, texCoords);
        }

        window.onload = main;
    </script>
</body>
</html>
